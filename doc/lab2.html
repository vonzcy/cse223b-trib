<h2>
<a name="user-content-lab2" class="anchor" href="#lab2"><span class="octicon octicon-link"></span></a>Lab2</h2>

<p>Welcome to Lab2. The goal of this lab is to use the RPC key-value pair
we built in Lab 1 to implement scalable Tribbler front-ends and
back-ends. In particular, you need to implement a stateless Tribbler
front-end type that fits <code>trib.Server</code> interface and can perform calls
to a list of remote RPC key-value pair back-end server, which save all
the user information and Tribbles in a distributed fashion.</p>

<h2>
<a name="user-content-get-your-repo-up-to-date" class="anchor" href="#get-your-repo-up-to-date"><span class="octicon octicon-link"></span></a>Get Your Repo Up-to-date</h2>

<p>First we update the <code>trib</code> repo:</p>

<pre><code>$ cd ~/gopath/src/trib
$ git pull /classes/cse223b/sp14/labs/trib lab2
</code></pre>

<p>If you have not changed anything in <code>trib</code> repo, this should be
painless. However, if you changed stuff, you need to merge the
changes.</p>

<p>Now update the <code>triblab</code> repo by merging branch <code>lab2</code>. There will be
several changes:</p>

<ul>
<li>Some line changes in <code>makefile</code>.</li>
<li>Some added lines in <code>lab2.go</code>.</li>
<li>A new file called <code>server_test.go</code>.</li>
</ul><p>If you have not touched those files and have not created a file called
<code>server_test.go</code> by yourself, the merge should be painless:</p>

<pre><code>$ cd ~/gopath/src/triblab
$ git pull /classes/cse223b/sp14/labs/triblab lab2
</code></pre>

<p>If you have made changes to those files. Then you need to merge the
changes properly.</p>

<h2>
<a name="user-content-tribble" class="anchor" href="#tribble"><span class="octicon octicon-link"></span></a>Tribble</h2>

<p>A Tribble is a structure type that has 4 fields:</p>

<pre><code>type Trib struct {
    User    string    // who posted this trib
    Message string    // the content of the trib
    Time    time.Time // the physical timestamp
    Clock   uint64    // the logical clock
}
</code></pre>

<p><code>Time</code> is what the front-end claims when this tribble is created, by
reading the front-end's own physical time clock on the machine when
<code>Post()</code> in a <code>trib.Server</code> is called.  However, to sort tribbles in a
globally consistent and reasonable order, we can not sort the tribbles
only by this timestamp, because different front-ends have different
physical time readings. For sorting, Tribbler service needs to
maintain a distributed logical <code>Clock</code> in <code>uint64</code>.</p>

<p>When sorting many tribbles into a single timeline, you should sort by
the fields following this priority:</p>

<ol>
<li>
<code>Clock</code> The logical timestamp.</li>
<li>
<code>Time</code> The physical timestamp.</li>
<li>
<code>User</code> The user id</li>
<li>
<code>Message</code> The message content.</li>
</ol><p>We call this the <em>Tribble Order</em>.</p>

<h2>
<a name="user-content-tribbler-service-interface" class="anchor" href="#tribbler-service-interface"><span class="octicon octicon-link"></span></a>Tribbler Service Interface</h2>

<p>The Tribbler service logic is all defined in <code>trib.Server</code> interface
(in <code>trib/trib.go</code> file). This is how the webpage user interface
interacts with a Tribbler server.</p>

<hr><pre><code>SignUp(user string) error
</code></pre>

<p>Creates a new user. After a user is created, it will never disappear
in the system.  </p>

<p>A valid user name must be no longer than <code>trib.MaxUsernameLen=15</code>
characters but not empty, must start with a lower-case letter, and can
only contain lower-case letters or numbers.  There is a helper
function called <code>trib.IsValidUsername(string)</code> which you can use to
check if a username is valid.</p>

<p>Returns error when the username is invalid or the user already exists.
Concurrent sign-ups might both succeed.</p>

<hr><pre><code>ListUsers() ([]string, error)
</code></pre>

<p>Lists at least <code>trib.MinListUser=20</code> different registered users. When
there are less than 20 users that have ever signed up, list all of
them. The returned usernames should be sorted in alphabetical order.</p>

<p>This is just for showing some users on the front page; this is not for
listing all the users that have ever signed up, because that would be
too expensive in a scalable system.</p>

<hr><pre><code>Post(who, post string, clock uint64) error
</code></pre>

<p>Posts a tribble. <code>clock</code> is the maximum clock value this user client
has ever seen so far by reading tribbles (via <code>Home()</code> and <code>Tribs()</code>).
It returns error when the user does not exist or the post is too long
(longer than <code>trib.MaxTribLen=140</code>).</p>

<hr><pre><code>Tribs(user string) ([]*Trib, error)
</code></pre>

<p>Lists the recent <code>trib.MaxTribFetch=100</code> tribbles that a user posted.
Tribbles needs to be sorted in the Tribble Order. Also, it should make
sure that the order is the same order that the user posted the
tribbles.</p>

<hr><pre><code>Follow(who, whom string) error
Unfollow(who, whom string) error
IsFollowing(who, whom string) (bool, error)
Following(who string) ([]string, error)
</code></pre>

<p>These are functions to follow/unfollow, check following and listing
all following users of a user. A user can never follow or unfollow
himself. When calling with <code>who</code> equals to <code>whom</code>, the functions
return error. When the user does not exist, the functions return
error.</p>

<p>A user can follow at most <code>trib.MaxFollowing=2000</code> users. Returns
error when trying to follow more than that.</p>

<hr><pre><code>Home(user string) ([]*Trib, error)
</code></pre>

<p>List the recent <code>trib.MaxTribFetch=100</code> tribbles that are posted on
the user's following timeline in Tribble Order.  In addition, the
ordering should always satisfy that:</p>

<ol>
<li>If a tribble A is posted after a tribble B is posted, and they are
posted by the same user, A always shows after B.</li>
<li>If a tribble A is posted 10 seconds after a tribble B is posted,
even if they are posted by different users, A always shows after B.<br>
</li>
<li>If a tribble A is posted after a user client sees tribble B, A
always shows after B.</li>
</ol><p>A is <em>posted after</em> B means B calls <code>Post()</code> after A's <code>Post()</code>
returned.</p>

<p>It returns error when the user does not exist.</p>

<hr><p>In addition to normal errors, it might also return IO errors if the
implementation needs to communicate to a remote part.  Returning a nil
error means that the call is successfully executed; returning a
non-nil error means that the call might be succefully executed or not.</p>

<h2>
<a name="user-content-system-architecture" class="anchor" href="#system-architecture"><span class="octicon octicon-link"></span></a>System Architecture</h2>

<p>The system architecture looks like this:</p>

<p><a href="./arch.png" target="_blank"><img src="./arch.png" alt="System Arch" style="max-width:100%;"></a></p>

<p>Users use the Tribbler system from their browsers, each user visiting
one state-less front-end at a time (probably distributed via DNA
multiplexing). Upon a service request, the front-end will translate
the request into key-value pair requests and issue these requests to
the back-ends over RPC. The back-ends can talk to each other via
back-end peering channels (which you will implement with your own
design), so that they can sync on their view of the world from
time to time.</p>

<p>The peering channels should serve for these purposes:</p>

<ol>
<li>Coarse grained time synchronization, so that the clock in the system
won't be offset too much.</li>
<li>Fault detection, so that when a back-end joins or leaves, the
system can adjust itself.</li>
<li>Consistent storage management, so that when a back-end joins or
leaves, the system won't lose any-data and keeps the service
in a consistent view.</li>
</ol><h2>
<a name="user-content-entry-functions" class="anchor" href="#entry-functions"><span class="octicon octicon-link"></span></a>Entry Functions</h2>

<p>You can find these entry functions in <code>lab2.go</code> file under
<code>triblab</code> repo:</p>

<pre><code>func NewHashClient(backs []string) trib.MapStorage
</code></pre>

<p>This function is similar to <code>NewClient()</code> in <code>lab1.go</code> but
instead returns a <code>trib.HashStorage</code> interface.
<code>trib.MapStorage</code> has only one function called <code>Map()</code>,
which takes a string and returns a <code>trib.Storage</code>. A
hash storage provides another layer of mapping,
where the caller will first get a key-value storage
for the key string specified and then perform
key-value function calls defined in <code>trib.Storage</code> interface.
Different key strings should logically return completely
separate key-value stores, but note that key-value stores
for different key strings can actually physically share a single
store by appending the mapping key string as a prefix to the
storage key.
Just don't forget to escape the prefix suffix character
in the hash string.</p>

<hr><pre><code>func ServeKeeper(b *trib.KeeperConfig) error
</code></pre>

<p>This function is a blocking function (similar to <code>ServeBack()</code>).
It will spawn a keeper instance that maintains the
distributed back-ends in consistent state. For Lab2,
the keepers do not need to do much, but in Lab3, they
will be responsible for handling all the back-end joining,
leaving, faults and key migrations. In Lab2, there
will be only one keeper, but in Lab3, there
will be multiple keepers for fault-tolerent.</p>

<p>The <code>trib.KeeperConfig</code> structure contains all the
back-end serving addresses and also a set of peering
information for the keepers:</p>

<ul>
<li>
<code>Backs []string</code> These are the addresses of the back-ends.
These are the back-ends that the keeper needs to maintain.</li>
<li>
<code>Keepers []string</code> These are the addresses that the
keeper will listen on so that all the keepers can talk
to each other. For Lab2, there will be only one keeper,
and for that, you don't have to listen on this address,
since nobody will ring the bell.</li>
<li>
<code>This int</code> The index of this keeper (in the <code>Keepers</code> list).
For Lab2, it will always be zero.</li>
<li>
<code>Id int64</code> A non-zero incarnation identifier for this keeper,
usually derived from system clock. For Lab2, this
fields does not matter.</li>
</ul><p>A keeper can do whatever it wants to do, but a keeper
should be only maintain the general key-pair service
in consistent state, and maybe also keep the back-ends'
logical clocks coarsely synchronized. A keeper
should understand the hashing prefix, but should not
need to parse anything further beyond the prefix
in the keys or the values. This means the keeper
should not rely on how Tribbler uses the key-value storage,
In fact, your Tribbler should just work if the back-ends.</p>

<hr><pre><code>func NewFront(hs trib.MapStorage) trib.Server
</code></pre>

<p>This function takes the addresses of the backends, and returns an
implementation of <code>trib.Server</code>. The returned instance then will serve
as an service front-end that takes Tribbler service function calls,
and translates them into key-value pair RPC calls. This front-end
should be stateless, thread safe, and ready to be killed at any time.
This means that at any time during its execution, the back-end
key-value pair storage always needs to stay in a consistent state.
Also, note that one front-end might be taking multiple
concurrent requests from the Web,
and there might be multiple front-ends talking to the same
back-end, so make sure it handles all the concurrency issues
correctly.</p>

<h2>
<a name="user-content-playing-with-it" class="anchor" href="#playing-with-it"><span class="octicon octicon-link"></span></a>Playing with It</h2>

<p>Since we might have multiple back-ends running at the same time.
To work with that, we will have a configuration file that
specifies the serving address (which accepts connections from front-ends)
and the peering address (which accepts connections from back-end peers).
The config file by default will use <code>trib.rc</code> as its file name.</p>

<p><code>trib.rc</code> is saved in json format, marshalling a <code>RC</code> structure type
(defined in <code>trib/rc.go</code> file).
We have a utility program called <code>trib-mkrc</code>
that can generate a <code>trib.rc</code> file
automatically.</p>

<p>Find a directory as your working directory (like <code>triblab</code>).</p>

<pre><code>$ trib-mkrc -local -nback=3
</code></pre>

<p>This will generate a file called <code>trib.rc</code> under the current
directory, and also print the file content to stdout.  <code>-local</code> means
that all addresses will be on <code>localhost</code>.  <code>-n=3</code> means there are in
total 3 back-ends.  If you remove <code>-local</code>, then it will generate
back-ends starting from <code>172.22.14.211</code> through <code>172.22.14.220</code>, which
are the IP address of our lab machines. There can be 10 backends in
maximum.</p>

<p>With this configuration file, we can now launch the
back-ends:</p>

<pre><code>$ trib-back
</code></pre>

<p>This will read and parse the <code>trib.rc</code> file, and spawn all the
back-ends which serving addresses are on this host. Since all the
back-ends we generate here are on <code>localhost</code>, so all the back-ends
are spawned for this case (in different go routines). You should see
three log lines showing that three back-ends just started.</p>

<p>Next for the front-end part:</p>

<pre><code>$ trib-front -init -addr=:rand -lab
</code></pre>

<p>You have used this utility before. The only new thing here is the
<code>-lab</code> flag, which tells it to read the <code>trib.rc</code> file and use our lab
implementation. This will start a stateless front-end (which you
implemented in this lab) that will connect to the back-ends service
addresses specified in <code>trib.rc</code>.</p>

<p>Again <code>-init</code> will populate the service with some sample data.</p>

<p>Now you can open your browser, connect to the front-end machine and
play with your own implementation.</p>

<p>If you want to use some other config file, use the <code>-rc</code> flag.
It is supported in all <code>trib-*</code> utilities.</p>

<p>Note that, when you completes this lab, it should be perfectly fine to
have multiple front-ends that connects to the set of back-ends.
Also both the front-ends and the back-ends should be scalable.</p>

<h2>
<a name="user-content-assumptions" class="anchor" href="#assumptions"><span class="octicon octicon-link"></span></a>Assumptions</h2>

<p>These are some unreal assumptions you can have for Lab2.</p>

<ul>
<li>No network communication error will happen.</li>
<li>Once a back-end or a keeper starts, it will remain online forever.</li>
<li>The <code>trib.Storage</code> used in the backend will return every <code>Clock()</code>
call in less than 1 second.</li>
<li>In the <code>trib.Storage</code> used in the backend, each key visiting
(checking if the key exist, locating its corresponding value, or as
a process of iterating all keys) will take less than 1 millisecond.
Read and write 1MB of data on the value part (in a list or a string)
will take less than 1 millisecond.  Note that <code>Keys()</code> and
<code>ListKeys()</code> might take longer time to complete because it needs to
scan over all the keys.</li>
<li>All front-ends, back-ends and keepers will run on the lab machines.</li>
</ul><p>Note that some of them won't stay true in Lab3, so
try not to rely on the assumptions too much.</p>

<h2>
<a name="user-content-requirements" class="anchor" href="#requirements"><span class="octicon octicon-link"></span></a>Requirements</h2>

<ul>
<li>The back-ends should be able to start one-by-one in arbitrary order.
without any error.</li>
<li>When the service function call has valid arguments, the function
call should not return any error.</li>
<li>The front-ends part should be stateless and hence ready to be killed
at anytime.</li>
<li>When the back-end is the system throughput bottleneck, adding more
back-ends should increase the number of service function calls the
system can serve per second.</li>
<li>When running on the lab machines, with more than 5 back-ends
supporting, each Tribbler service call should return in 3 seconds.</li>
<li>Each back-ends should maintain the same general key-value pair
semantics as they were in Lab1. As a result, all test cases that
pass for Lab1 should also pass for Lab2. This means that, the
back-ends do not need to understand anything about the front-ends
(like how the keys will be structured and organized, or how to parse
the values).</li>
</ul><h2>
<a name="user-content-building-hints" class="anchor" href="#building-hints"><span class="octicon octicon-link"></span></a>Building Hints</h2>

<p>While you are free to build the front-ends and the back-ends in
your own way, here are some suggested hints:</p>

<ul>
<li>For each service call in the front-end, if it updates anything in
the back-end storage, use only one write-RPC call. This will make
sure it the call either succeed or fail.</li>
<li>Hash the tribbles and other information into all the back-ends based
on username. You may find the package <code>hash/fnv</code> helpful for
hashing.</li>
<li>Synchronize the logical clocks among all the back-ends every second.
(This will also serve as a heart-beat signal, which will be useful
for implementing Lab3.) However, you should not try to synchronize
the clocks for every post, because that will be not scalable.</li>
<li>Do some garbage collection when one user have too many tribbles
saved in the storage.</li>
<li>Keep a cache for the ListUsers() call when the users are many.</li>
</ul><h2>
<a name="user-content-common-mistakes" class="anchor" href="#common-mistakes"><span class="octicon octicon-link"></span></a>Common Mistakes</h2>

<p>Here are some common mistakes that a lazy and quick
but incorrect implementation might do:</p>

<ul>
<li>
<strong>Read-modify-write</strong>. For example, a tribbler might read a counter
from the key-value store, increase it by one and then write it back
(at the same key).  This will introduce racing condition among the
front-ends.</li>
<li>
<strong>Not handling errors</strong>. A tribbler service call might require
several RPC calls to the backend. It is important to properly handle
<em>any</em> error returned by these calls. It is okay to tell the webpage
that an error occurred. However, it is often not a good idea to leave
the back-end in inconsistent state.</li>
<li>
<strong>Sorting by the timestamps first</strong>. Again, the Tribble Order means
that the logic clock is the first field to consider on sorting.</li>
<li>
<strong>Misuse the clock argument in Post()</strong>. For example, you
might directly use that argument as the new post's clock field.
Technically, you can do that in your code internally as long as you
can satisfy the ordering requirements specified for <code>Home()</code> and
<code>Tribs()</code> (you might find it very hard).  Nonetheless, intuitively,
the clock argument tells the <em>oldest</em> tribble a user have seen
(which might be 0 if the user has not seen any tribble yet), hence
the new posted tribble seems to better have a clock value that is
larger than the argument.</li>
<li>
<strong>Generate the clock from the timestamp</strong>. While 64-bit can cover a
very wide time range even in the unit of nanoseconds, you should
keep in mind that the front-ends are running on different servers
with arbitrary physical time differences, so it is not wise to
generate the logical <em>clock</em> from the physical <em>time</em>.</li>
<li>
<strong>Not handling old tribbles</strong>. Note that only the most recent 100
tribbles of a user matter. Not handling old tribbles might lead to
worse and worse performance over time and eventually break the
performance promise.</li>
</ul><h2>
<a name="user-content-turning-in" class="anchor" href="#turning-in"><span class="octicon octicon-link"></span></a>Turning In</h2>

<p>First, make sure that you have committed every piece
of your code into the repository <code>triblab</code>. Then just
type <code>make turnin</code> under the root of the repository.
It will generate a <code>turnin.zip</code> that contains everything
in your git repository, and will then copy the zip file to
a place where only the lab instructors can read.</p>

<h2>
<a name="user-content-happy-lab2" class="anchor" href="#happy-lab2"><span class="octicon octicon-link"></span></a>Happy Lab2</h2>
